# Задача 1

В файле **read_devices.c** написана функция **open_and_read**, которая в качестве аргумента получает имя устройства, с которого необходимо считать данные и считывает 100 байт информации из этого устройства.

В основной функции **main** вызывается функция  **open_and_read** для устройств **/dev/zero** и **/dev/random**

Для компиляции файла используется **Makefile**

# Задача 2
При помощи утилиты **strace** необходимо отследить системные выховы при работе приложения **./read_devices**. 
Вывод вызова утилиты **strace** представлен в файле **strace_output.txt**. 

## Подсистема файловой системы (`fs/`)

- **openat(dirfd, path, flags)** → открыть файл или устройство (например `/dev/zero`), вернуть файловый дескриптор.  
- **read(fd, buf, count)** → прочитать до `count` байт из файла/устройства в память.  
- **write(fd, buf, count)** → записать данные из памяти в файл/устройство (в нашем случае — вывод на экран).  
- **close(fd)** → закрыть файловый дескриптор, освободить ресурсы ядра.  
- **fstat(fd, statbuf)** → получить метаданные файла (тип, права, размер).  
- **pread64(fd, buf, count, offset)** → прочитать данные из файла по смещению (используется загрузчиком библиотек).  
- **access(path, mode)** → проверить доступность файла (существует ли, права на чтение/запись/выполнение).  

## Подсистема управления памятью (`mm/`)

- **brk(addr)** → увеличить или уменьшить сегмент кучи (используется `malloc`).  
- **mmap(addr, length, prot, flags, fd, offset)** → отобразить файл или анонимную область памяти в адресное пространство процесса.  
- **munmap(addr, length)** → убрать отображение памяти (освободить область).  
- **mprotect(addr, length, prot)** → изменить права доступа (чтение/запись/исполнение) для области памяти.  
- **arch_prctl(option, addr)** → архитектурно-специфичная настройка потока (например, база TLS регистра).  
- **prlimit64(pid, resource, new, old)** → получить или установить лимиты ресурсов (например, размер стека, число открытых файлов)

# Задача 3
Найти системные вызовы в исходниках ядра для вашего ядра.
Версия ядра после вызова **uname -r**: 6.14

Чтобы найти файл, содержащий код для системного вызова, например, openat, необходимо вызвать утилиту **grep -R "SYSCALL_DEFINE.\*openat" fs/**

В таблице представлены некоторые системные вызовы, которые были прочитаны с помощью утилиты **strace**
| Системный вызов | Исходный файл в ядре       | Определение                                                                 |
|-------------|------------------|-----------------------------------------------------------------------------|
| openat      | fs/open.c        | `SYSCALL_DEFINE4(openat, int dfd, const char __user *filename, int flags, umode_t mode)` |
| read        | fs/read_write.c  | `SYSCALL_DEFINE3(read, unsigned int fd, char __user *buf, size_t count)`    |
| write       | fs/read_write.c  | `SYSCALL_DEFINE3(write, unsigned int fd, const char __user *buf, size_t count)` |
| mmap        | mm/mmap.c        | `SYSCALL_DEFINE6(mmap_pgoff, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff)` |
| brk         | mm/mmap.c        | `SYSCALL_DEFINE1(brk, unsigned long brk)`                                   |

