# Network driver
Purpose: Virtual Loopback Ethernet device
Number of interfaces: 1 (vnet0)
TX -> RX model: 
    - TX enqueues packer
    - RX happens via NAPI
RX-queue: per-device
NAPI: 
    - Proccess packets in batches
    - Avoid re-entrancy problems
    - Model real NIC RX behavior
Who schedules NAPI:
    - ndo_start_xmit() schedules NAPI. because TX simulates “hardware produced packet”
Packet processing:
    - Lives in a separate helper function
    - Is called from RX path
    - Filtering by protocol
Concurrency:
    - Both TX and NAPI access RX queue
RX-full behavior:
    - Drop packet
    - Increment rx_dropped
    - Optionally stop TX queue
Testing:
    - ping
    - ip -s link
Github:
    - Architecture diagram
    - Performance test

## Step 1. Fix device allocation
Current structure:
struct net_device
├── name: vnet0
├── net_device_ops
└── private data (vnet_priv)
    └── spinlock_t spinlock

### How to check
1) make
2) sudo insmod vnet_driver.ko
3) ip link show

## Step 2
### What should be initialized in vnet_setup()?
This function describes, what this device is.
This function is static and for every device...
- RX queue
- Spinlock 
- Statistic counters 
Thus, the following things should not be initialize in vnet_setup():
- NAPI
    - It is runtime
    - Belongs to device lifecycle
- TX queue
    - It exists always, but is running only, when interface is UP

### Driver properties
- MTU: 1400
- MAC address: Randomly generated by kernel (using helper) 
- Supports broadcast
- Supports multicast
- Does not need ARP suppression
- ARP enabled

## Step 3. Implement device lifecycle management
